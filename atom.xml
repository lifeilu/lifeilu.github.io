<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>菲菲馡的个人小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-15T02:14:51.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>lifeilu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Native-H5-Communication</title>
    <link href="http://yoursite.com/2018/03/15/native-h5-communication/"/>
    <id>http://yoursite.com/2018/03/15/native-h5-communication/</id>
    <published>2018-03-15T01:52:32.000Z</published>
    <updated>2018-03-15T02:14:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://lifeilu.github.io/2017/11/24/cordova-plugin-inappbrowser/" target="_blank" rel="external">上篇博客</a>提到，在H5开发的app中，希望调用手机自带浏览器显示附件,<br>在实际开发过程中，经常会用到原生app和H5互相调用的问题，<br>之前没有具体了解调用的机制，包括Native和H5如何互相通讯的实现机制。<br>近期参考了一些资料，整理成这篇博客。<br>方便之后继续完善。</p><p>原生和前端的交互有两种方式：url scheme以及JavaScriptCore（在Android中是addJavascriptInterface）</p><h2 id="url-scheme交互"><a href="#url-scheme交互" class="headerlink" title="url scheme交互"></a>url scheme交互</h2><p>url scheme适用于所有的系统设备（低版本Android和低版本iOS都适用）<br>但是url scheme是通过url拦截实现的，在大量数据传输，以及效率上都有影响。<br>基本原理为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">H5 -&gt; 触发一个url（每一个功能代表的url都不同）-&gt; Native端捕获到url-&gt;</div><div class="line">Native端分析属于哪一个功能并执行 -&gt;Native端调用H5中的方法将执行结果回调给H5</div></pre></td></tr></table></figure><h2 id="H5直接与Native交互"><a href="#H5直接与Native交互" class="headerlink" title="H5直接与Native交互"></a>H5直接与Native交互</h2><h3 id="H5调Android"><a href="#H5调Android" class="headerlink" title="H5调Android"></a>H5调Android</h3><p>原生通过addJavascriptInterface注册，然后H5直接调用</p><h3 id="Android调H5"><a href="#Android调H5" class="headerlink" title="Android调H5"></a>Android调H5</h3><p>原生通过loadUrl来调用H5，4.4及以上还可以通过evaluateJavascript调用</p><h3 id="H5调iOS"><a href="#H5调iOS" class="headerlink" title="H5调iOS"></a>H5调iOS</h3><p>原生通过JavaScriptCore注册（需ios7以上），然后H5直接调用</p><h3 id="iOS调H5"><a href="#iOS调H5" class="headerlink" title="iOS调H5"></a>iOS调H5</h3><p>通过stringByEvaluatingJavaScriptFromString</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.cnblogs.com/dailc/p/8097598.html" target="_blank" rel="external">H5和Native交互原理</a></li><li><a href="https://tech.youzan.com/jsbridge/" target="_blank" rel="external">H5与Native交互之JSBridge技术</a></li><li><a href="https://juejin.im/post/58bb8a24128fe10064431b68" target="_blank" rel="external">JavaScript调用App原生代码(iOS、Android)解决方案</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在&lt;a href=&quot;https://lifeilu.github.io/2017/11/24/cordova-plugin-inappbrowser/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上篇博客&lt;/a&gt;提到，在H5开发的app中，希望调用手机自
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Native" scheme="http://yoursite.com/tags/Native/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>cordova-plugin-inappbrowser在app内部打开浏览器链接</title>
    <link href="http://yoursite.com/2017/11/24/cordova-plugin-inappbrowser/"/>
    <id>http://yoursite.com/2017/11/24/cordova-plugin-inappbrowser/</id>
    <published>2017-11-24T05:08:49.000Z</published>
    <updated>2017-11-24T05:21:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>在使用vue.js进行app开发的时候，需要实现附件点击，可以查看和下载的功能。<br>原始的实现方案代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">onClick: function() &#123;</div><div class="line">    var a = document.createElement(&apos;a&apos;)</div><div class="line">    a.href = url</div><div class="line">    a.click()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个方案在安卓下是自动跳转到默认浏览器打开，可以自行选择查看还是下载，但是在iOS下，会在<strong><font color="red">app内部打开，由于iOS没有返回按钮，只能杀掉app,重新进入</font></strong>，不符合要求。<br>查阅资料发现，可以采用<a href="https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/" target="_blank" rel="external">cordova-plugin-inappbrowser</a>实现在app内部打开浏览器链接。<br>具体代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">onClick: function() &#123;</div><div class="line">    if (!cordova.InAppBrowser) &#123;</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    cordova.InAppBrowser.open(url, &apos;_system&apos;, &apos;location=no,toolbar=yes,toolbarposition=top,closebuttoncaption=关闭&apos;)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>经过测试，在iOS和安卓下均可实现点击链接打开默认浏览器，即可自行选择打开还是保存。</p><p>参考文献<br>1.<a href="http://www.cnblogs.com/maoyazhi/p/5291015.html" target="_blank" rel="external">http://www.cnblogs.com/maoyazhi/p/5291015.html</a><br>2.<a href="https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/" target="_blank" rel="external">https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-inappbrowser/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在使用vue.js进行app开发的时候，需要实现附件点击，可以查看和下载的功能。&lt;br&gt;原始的实现方案代码如下&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=
      
    
    </summary>
    
    
      <category term="vue.js" scheme="http://yoursite.com/tags/vue-js/"/>
    
      <category term="ios" scheme="http://yoursite.com/tags/ios/"/>
    
  </entry>
  
  <entry>
    <title>移动端Web页面适配方案</title>
    <link href="http://yoursite.com/2017/11/09/html-viewport-set/"/>
    <id>http://yoursite.com/2017/11/09/html-viewport-set/</id>
    <published>2017-11-09T08:41:00.000Z</published>
    <updated>2017-11-21T01:54:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>延续之前的移动端项目开发，需求要求把从后台获取到的一段html显示在界面上。</p><h1 id="v-html解析html文本"><a href="#v-html解析html文本" class="headerlink" title="v-html解析html文本"></a>v-html解析html文本</h1><p>在Vue.js上有个指令是<a href="https://cn.vuejs.org/v2/api/#v-html" target="_blank" rel="external">v-html</a>。具体语法是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div v-html=&quot;html&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p><p>其中html部分替换成要绑定的html就可以了，v-html可以解析html代码段并显示出来。<br>还有一个相似的指令<a href="https://cn.vuejs.org/v2/api/#v-text" target="_blank" rel="external">v-text</a>可以将以文字部分显示出来。<br>以上就完成了将html插入页面的操作。<br>但是存在着问题，<strong><font color="red">插入的html是web页面格式的，显示在移动端的时候会出现横向滚动条</font></strong>，<br>不符合我们项目的要求。因此，如何才能适配呢？</p><h1 id="meta标签的viewport"><a href="#meta标签的viewport" class="headerlink" title="meta标签的viewport"></a>meta标签的viewport</h1><p>通过设置html的meta标签的viewport属性。这里有详细的<a href="https://www.cnblogs.com/2050/p/3877280.html" target="_blank" rel="external">viewport</a>的介绍<br>可以在要插入的html文本的head部分加入如下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&apos;viewport&apos; content=&apos;width=device-width&apos;&gt;</div></pre></td></tr></table></figure></p><p>这样即可完成视口的设置，在chrome浏览器和android设备上测试，均可正常显示。<br>但是在<strong><font color="red">iOS设备上并没有起效</font></strong>。查找原因，发现需要配置config文件。</p><h2 id="iOS上设置config文件"><a href="#iOS上设置config文件" class="headerlink" title="iOS上设置config文件"></a>iOS上设置config文件</h2><p>需要把config.xml下的EnableViewportScale改为true<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;preference name=&quot;EnableViewportScale&quot; value=&quot;true&quot; /&gt;</div></pre></td></tr></table></figure></p><p>这样即可完成视口的调整，完成web页面和移动端的适配。<br>但是由于要插入html的页面还有其他内容，大体的结构是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&apos;div1&apos;&gt;&lt;/div&gt;</div><div class="line">&lt;div v-html=&apos;html&apos;&gt;&lt;/div&gt;</div><div class="line">&lt;div id=&apos;div2&apos;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p><p>在设置了viewport之后会导致整个页面缩放的效果，从而导致<strong><font color="red">div1和div2的内容也进行了缩放</font></strong>，不符合我们的要求。</p><h1 id="iframe嵌入html文本"><a href="#iframe嵌入html文本" class="headerlink" title="iframe嵌入html文本"></a>iframe嵌入html文本</h1><p>考虑到使用<a href="http://www.runoob.com/tags/tag-iframe.html" target="_blank" rel="external">iframe</a>定义一个内联框架，可以用来在当前html文档中嵌入另一个文档。具体语法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&apos;iframeWrapper&apos;&gt;</div><div class="line">  &lt;iframe :srcdoc=&apos;content&apos;&gt;&lt;/iframe&gt;</div><div class="line">  或者</div><div class="line">  &lt;iframe src=&apos;content.html&apos;&gt;&lt;/iframe&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p><p>通过设定iframe的src可以完成嵌入html的操作。在chrome和android设备上测试通过，<br>但是<strong><font color="red">在iOS设备上，iframe不能正常显示</font></strong>。同样，需要配置config文件。</p><h2 id="iOS上设置config文件-1"><a href="#iOS上设置config文件-1" class="headerlink" title="iOS上设置config文件"></a>iOS上设置config文件</h2><p>查阅<a href="http://blog.csdn.net/ilv_xj/article/details/72778501" target="_blank" rel="external">资料</a>得知，需要在config.xml里配置权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;allow-navigation href=&quot;*&quot;/&gt;</div><div class="line">&lt;allow-intent href=&quot;*&quot;/&gt;</div><div class="line">&lt;access origin=&quot;*&quot; /&gt;</div></pre></td></tr></table></figure></p><p>配置完成之后，iOS设备也可显示iframe，接下来要设置iframe的格式了。</p><h2 id="iframe动态适配高度和宽度"><a href="#iframe动态适配高度和宽度" class="headerlink" title="iframe动态适配高度和宽度"></a>iframe动态适配高度和宽度</h2><p>承接上面的问题，嵌入的html文本是带格式的，我们需要动态设置iframe的高度和宽度，使得它的宽度正好为设备的宽度，不再出现横向滚动条。<br>具体做法为在iframe的onload事件中设置样式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">onloaded: function () &#123;</div><div class="line">  var iframe = document.getElementById(&apos;iframe&apos;)</div><div class="line">  var height = iframe.contentWindow.document.body.scrollHeight || iframe.contentWindow.document.documentElement.scrollHeight</div><div class="line">  var width = iframe.contentWindow.document.body.scrollWidth || iframe.contentWindow.document.documentElement.scrollWidth</div><div class="line">  iframe.height = height</div><div class="line">  iframe.width = width</div><div class="line">  iframe.style.minWidth = width</div><div class="line">  iframe.style.minHeight = height</div><div class="line">  var clientwidth = document.documentElement.clientWidth</div><div class="line">  var scale = clientwidth / width</div><div class="line">  iframe.style.transform = &apos;scale(&apos; + scale + &apos;)&apos;</div><div class="line">  iframe.style.transformOrigin = &apos;0 0&apos;</div><div class="line">  iframe.style.border = &apos;none&apos;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如上面代码所示，可以通过设置<strong>transform的scale</strong>属性完成缩放的操作，在缩放之后需要把transformOrigin属性(默认50% 50%)设置一下，以上完成了缩放的操作。<br>但是发现<strong><font color="red">scale虽然缩放了，但是并没有影响布局，元素还占用了之前的空间</font></strong>，这里有<a href="https://segmentfault.com/q/1010000005919829" target="_blank" rel="external">说明</a>,<br>导致页面中间有一段空白。<br>因此，需要<strong>动态调整iframe外层的div元素的高度</strong>，具体代码示例如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.parent.document.getElementById(&apos;iframeWrapper&apos;).style.height = height * scale + &apos;px&apos;</div></pre></td></tr></table></figure></p><p>这样可以实现iframe和父元素的高度随着插入html的高度自适应变化。</p><h2 id="onload函数调用了两次"><a href="#onload函数调用了两次" class="headerlink" title="onload函数调用了两次"></a>onload函数调用了两次</h2><p>测试过程中发现，<strong><font color="red">onload函数调用了两次</font></strong>。调整代码结构，将html文本中的iframe标签去掉，通过js来动态增加iframe元素。完整代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">onLoaded: function (content) &#123;</div><div class="line">  var ifrWrapper = document.getElementById(&apos;iframeWrapper&apos;)</div><div class="line">  var iframe = document.createElement(&apos;iframe&apos;)</div><div class="line">  iframe.onload = function () &#123;</div><div class="line">    var clientwidth = document.documentElement.clientWidth</div><div class="line">    var height = iframe.contentWindow.document.body.scrollHeight || iframe.contentWindow.document.documentElement.scrollHeight</div><div class="line">    var width = iframe.contentWindow.document.body.scrollWidth || iframe.contentWindow.document.documentElement.scrollWidth</div><div class="line">    iframe.height = height</div><div class="line">    iframe.width = width</div><div class="line">    iframe.style.minWidth = width</div><div class="line">    iframe.style.minHeight = height</div><div class="line">    var scale = clientwidth / width</div><div class="line">    iframe.style.transform = &apos;scale(&apos; + scale + &apos;)&apos;</div><div class="line">    iframe.style.transformOrigin = &apos;0 0&apos;</div><div class="line">    iframe.style.border = &apos;none&apos;</div><div class="line">    window.parent.document.getElementById(&apos;iframeWrapper&apos;).style.height = height * scale + &apos;px&apos;</div><div class="line">  &#125;</div><div class="line">  iframe.srcdoc = content</div><div class="line">  ifrWrapper.appendChild(iframe)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>以上的函数在从后台获取到要插入的html的内容的时候调用。<br>至此，通过iframe插入html文本并动态设置高度和宽度的功能就完成了。<br>但是页面调整到宽度跟设备宽度一致之后，<strong><font color="red">字号会变小</font></strong>，需求希望用户可以自己手势控制放大。之前想通过<strong><font color="red">设置viewport的user-scalable为yes</font></strong>来允许用户自行缩放，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=yes, initial-scale=1, maximum-scale=1, minimum-scale=1, width=device-width&quot;&gt;</div></pre></td></tr></table></figure></p><p>但是在子页面设置了user-scalable之后会导致整个app的<strong><font color="red">所有页面都可以用户缩放</font></strong>，不符合要求，<br>希望设置一个开关来完成user-scalable的yes或no，但是没有用，<a href="https://zhuanlan.zhihu.com/p/25140691" target="_blank" rel="external">这里</a>有详细的介绍<br>只能寻求其他的解决方案。</p><h1 id="AlloyFinger实现手势缩放"><a href="#AlloyFinger实现手势缩放" class="headerlink" title="AlloyFinger实现手势缩放"></a><a href="https://github.com/AlloyTeam/AlloyFinger" target="_blank" rel="external">AlloyFinger</a>实现手势缩放</h1><p>承接以上的问题，在实现缩小之后，<strong><font color="red">字号会变小</font></strong>，需求要求在这个页面可以<strong>手势放大(pinch事件)</strong>.<br>采用腾讯的<a href="https://github.com/AlloyTeam/AlloyFinger" target="_blank" rel="external">AlloyFinger</a>来控制用户两指缩放。<br>使用方式，首先安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install alloyfinger --save</div></pre></td></tr></table></figure></p><p>之后在页面引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">import AlloyFinger from &apos;alloyfinger&apos;</div></pre></td></tr></table></figure></p><p>然后在components中使用AlloyFinge。至此可以使用v-finger来实现手势的识别了。<br>参考代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var pinchRotateImg = document.getElementById(&quot;pinchRotateImg&quot;);</div><div class="line">Transform(pinchRotateImg);</div><div class="line">new AlloyFinger(pinchRotateImg, &#123;</div><div class="line">    rotate:function(evt)&#123;</div><div class="line">      pinchRotateImg.rotateZ += evt.angle;</div><div class="line">    &#125;,</div><div class="line">    multipointStart: function () &#123;</div><div class="line">      initScale = pinchRotateImg.scaleX;</div><div class="line">    &#125;,</div><div class="line">    pinch: function (evt) &#123;</div><div class="line">        pinchRotateImg.scaleX = pinchRotateImg.scaleY = initScale * evt.zoom;</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>在页面新加一个div的时候可以很容易的实现识别，但是在iframe上，由于需要在load完毕之后才有内容，因此，在之前的onLoaded函数里添加代码，<br>希望实现在只能放大，不能缩小到比原来初始化的时候小。具体完整版代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">onLoaded: function (content) &#123;</div><div class="line">    var ifrWrapper = document.getElementById(&apos;iframeWrapper&apos;)</div><div class="line">    var iframe = document.createElement(&apos;iframe&apos;)</div><div class="line">    iframe.onload = function () &#123;</div><div class="line">        var clientwidth = document.documentElement.clientWidth</div><div class="line">        var height = iframe.contentWindow.document.body.scrollHeight || iframe.contentWindow.document.documentElement.scrollHeight</div><div class="line">        var width = iframe.contentWindow.document.body.scrollWidth || iframe.contentWindow.document.documentElement.scrollWidth</div><div class="line">        iframe.height = height</div><div class="line">        iframe.width = width</div><div class="line">        iframe.style.minWidth = width</div><div class="line">        iframe.style.minHeight = height</div><div class="line">        var scale = clientwidth / width</div><div class="line">        iframe.style.border = &apos;none&apos;</div><div class="line">        iframe.style.transform = &apos;scale(&apos; + scale + &apos;)&apos;</div><div class="line">        iframe.style.transformOrigin = &apos;left top&apos;</div><div class="line">        ifrWrapper.style.height = height * scale + &apos;px&apos;</div><div class="line">        ifrWrapper.style.width = width * scale + &apos;px&apos;</div><div class="line"></div><div class="line">        var initScale = scale</div><div class="line">        new AlloyFinger(iframe.contentDocument, &#123;</div><div class="line">            multipointStart: function () &#123;</div><div class="line">              initScale = iframe.style.transform.split(&apos;(&apos;)[1].split(&apos;)&apos;)[0]</div><div class="line">            &#125;,</div><div class="line">            pinch: function (evt) &#123;</div><div class="line">              var newScale = initScale * evt.zoom</div><div class="line">              if (newScale &lt; scale) &#123;</div><div class="line">                ifrWrapper.style.overflowX = &apos;hidden&apos;</div><div class="line">                iframe.style.transform = &apos;scale(&apos; + scale + &apos;)&apos;</div><div class="line">                ifrWrapper.style.height = height * scale + &apos;px&apos;</div><div class="line">                ifrWrapper.style.width = width * scale + &apos;px&apos;</div><div class="line">                return</div><div class="line">              &#125;</div><div class="line">              iframe.style.transform = &apos;scale(&apos; + newScale + &apos;)&apos;</div><div class="line">              ifrWrapper.style.height = height * newScale + &apos;px&apos;</div><div class="line">              ifrWrapper.style.width = width * newScale + &apos;px&apos;</div><div class="line">              if (iframe.width &gt; width) &#123;</div><div class="line">                ifrWrapper.style.overflowX = &apos;scroll&apos;</div><div class="line">              &#125; else &#123;</div><div class="line">                ifrWrapper.style.overflowX = &apos;hidden&apos;</div><div class="line">              &#125;</div><div class="line">            &#125;</div><div class="line">          &#125;)</div><div class="line">    &#125;</div><div class="line">    iframe.srcdoc = item.content</div><div class="line">    ifrWrapper.appendChild(iframe)</div><div class="line">&#125;,</div></pre></td></tr></table></figure></p><p>以上即可实现相关的功能<br>其他的问题还在不断完善中…</p><p>参考文献<br>1.<a href="https://cn.vuejs.org/v2/api/#v-html" target="_blank" rel="external">https://cn.vuejs.org/v2/api/#v-html</a><br>2.<a href="https://segmentfault.com/a/1190000008767416" target="_blank" rel="external">https://segmentfault.com/a/1190000008767416</a><br>3.<a href="http://clfsw.iteye.com/blog/1398806" target="_blank" rel="external">http://clfsw.iteye.com/blog/1398806</a><br>4.<a href="http://www.runoob.com/tags/tag-iframe.html" target="_blank" rel="external">http://www.runoob.com/tags/tag-iframe.html</a><br>5.<a href="http://blog.csdn.net/ilv_xj/article/details/72778501" target="_blank" rel="external">http://blog.csdn.net/ilv_xj/article/details/72778501</a><br>6.<a href="https://segmentfault.com/q/1010000005919829" target="_blank" rel="external">https://segmentfault.com/q/1010000005919829</a><br>7.<a href="https://yq.aliyun.com/ziliao/167263" target="_blank" rel="external">https://yq.aliyun.com/ziliao/167263</a><br>8.<a href="https://zhuanlan.zhihu.com/p/25140691" target="_blank" rel="external">https://zhuanlan.zhihu.com/p/25140691</a><br>9.<a href="https://github.com/AlloyTeam/AlloyFinger" target="_blank" rel="external">https://github.com/AlloyTeam/AlloyFinger</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;延续之前的移动端项目开发，需求要求把从后台获取到的一段html显示在界面上。&lt;/p&gt;
&lt;h1 id=&quot;v-html解析html文本&quot;&gt;&lt;a href=&quot;#v-html解析html文本&quot; class=&quot;headerlink&quot; title=&quot;v-html解析html文本&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="vue.js" scheme="http://yoursite.com/tags/vue-js/"/>
    
      <category term="html" scheme="http://yoursite.com/tags/html/"/>
    
      <category term="移动端" scheme="http://yoursite.com/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>github pages 和 hexo 配置个人博客</title>
    <link href="http://yoursite.com/2017/11/07/myfirstblog/"/>
    <id>http://yoursite.com/2017/11/07/myfirstblog/</id>
    <published>2017-11-07T12:50:40.000Z</published>
    <updated>2017-11-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前在<a href="http://blog.csdn.net/Iohboel" target="_blank" rel="external">CSDN</a>上写博客，今天心血来潮，决定自己搭个博客。采用github pages 和 hexo,<br>现在把搭建过程和遇到的问题整理一下～</p><h1 id="新建git仓库"><a href="#新建git仓库" class="headerlink" title="新建git仓库"></a>新建git仓库</h1><p>这个过程很简单，在github上新建名字为 用户名.github.io 的仓库</p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g hexo-cli</div></pre></td></tr></table></figure><p>采用npm进行安装,安装过程报错，Permission denied<br>加了sudo<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g hexo-cli</div></pre></td></tr></table></figure></p><p>报错，cannot create highlight_alias.json: Permission denied<br>运行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm config set unsafe-perm true</div></pre></td></tr></table></figure></p><p>之后再安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g hexo-cli</div></pre></td></tr></table></figure></p><p>成功</p><h1 id="配置hexo"><a href="#配置hexo" class="headerlink" title="配置hexo"></a>配置hexo</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo init Code/Blog</div><div class="line">cd Code/Blog</div><div class="line">npm install</div></pre></td></tr></table></figure><h2 id="修改配置文件-config-yml"><a href="#修改配置文件-config-yml" class="headerlink" title="修改配置文件_config.yml"></a>修改配置文件_config.yml</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: https://github.com/lifeilu/lifeilu.github.io.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure><h2 id="本地测试"><a href="#本地测试" class="headerlink" title="本地测试"></a>本地测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo server</div></pre></td></tr></table></figure><p>可以本地在localhost里打开预览</p><h1 id="部署hexo到github"><a href="#部署hexo到github" class="headerlink" title="部署hexo到github"></a>部署hexo到github</h1><p>安装hexo-deployer-git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p><p>这样才能将你写好的文章部署到github服务器上并让别人浏览到。之后运行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean</div><div class="line">hexo generate</div><div class="line">hexo deploy</div></pre></td></tr></table></figure></p><p>以上就完成了博客的搭建。可以自己定义主题写博客咯～开心</p><h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><h2 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure><p>参考网址<br>1.<a href="http://blog.csdn.net/wlmnzf/article/details/73660441" target="_blank" rel="external">http://blog.csdn.net/wlmnzf/article/details/73660441</a><br>2.<a href="https://docs.npmjs.com/getting-started/fixing-npm-permissions" target="_blank" rel="external">https://docs.npmjs.com/getting-started/fixing-npm-permissions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前在&lt;a href=&quot;http://blog.csdn.net/Iohboel&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;CSDN&lt;/a&gt;上写博客，今天心血来潮，决定自己搭个博客。采用github pages 和 hexo,&lt;br&gt;现在把搭建过程和遇
      
    
    </summary>
    
      <category term="笔记" scheme="http://yoursite.com/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2017/11/07/hello-world/"/>
    <id>http://yoursite.com/2017/11/07/hello-world/</id>
    <published>2017-11-07T09:16:46.000Z</published>
    <updated>2017-11-07T09:16:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
